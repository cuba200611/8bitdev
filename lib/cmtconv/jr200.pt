from    cmtconv.jr200  import *
import  pytest

LL  = -32768
L   = -32600
Z   = 0
H   = 32600
HH  = 32767

@pytest.mark.parametrize('input, expected', (
    ((),                                ()),
    ((L, L, H, L),                      (0, 0, 1, 0)),
))
def test_samples_to_levels(input, expected):
    assert expected == samples_to_levels(input)

L = False
H = True
@pytest.mark.parametrize('input, expected', (
      ( (),             () ),
      ( ( L, H ),       ( (1, H, 1 ), ) ),
      ( ( L, L, H ),    ( ( 2, H, 2 ), ) ),
      ( (L, H, H, L ),  ( ( 1, H, 1 ), ( 3, L, 2 ) ) ),
))
def test_levels_to_timed_edges(input, expected):
    assert expected == levels_to_timed_edges(input, 1)


# space is 300-500 microseconds
s = 400.0 / 1.0e6
m = 200.0 / 1.0e6

def test_next_space():
    edges = ( ( 1, H, m ), ( 2, L, s ), ( 4, H, s ) )
    assert next_space( edges, 0, 1 ) == 1
    with pytest.raises(Exception) as ex:
        next_space( (), 0, 1 )
    edges = ( ( 2, H, s ), ( 3, L, m ),
        ( 5, H, s ), ( 7, L, s ), ( 8, H, m ) )
    assert next_space( edges, 0, 1 ) == 0
    assert next_space( edges, 0, 2 ) == 3

def test_is_mark():
    assert is_mark( (1, H, m) ) == True
    assert is_mark( (1, H, s) ) == False
    with pytest.raises(Exception) as ex:
        #is_mark( (1, H, 800.0 / 1.0e6 ) )
        # FIXME: is_mark is currently loosened to allow some weird cycles
        is_mark( (1, H, 1000.0 / 1.0e6 ) )

def test_eat_until_mark():
    with pytest.raises(Exception) as ex:
        eat_until_mark( (), 0 )
    edges = ( (1, H, m), )
    assert eat_until_mark( edges, 0 ) == ( 0, 0 )
